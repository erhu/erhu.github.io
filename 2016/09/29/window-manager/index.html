<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>从源码角度解析悬浮窗 | 四十岁退休</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">从源码角度解析悬浮窗</h1><a id="logo" href="/.">四十岁退休</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">从源码角度解析悬浮窗</h1><div class="post-meta">Sep 29, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>今天我们从源码角度来一探 Android 悬浮窗的究竟。</p>
<h2 id="一、如何创建一个悬浮窗"><a href="#一、如何创建一个悬浮窗" class="headerlink" title="一、如何创建一个悬浮窗"></a>一、如何创建一个悬浮窗</h2><ol>
<li>在 AndroidManifest.xml 中声明权限 android.permission.SYSTEM_ALERT_WINDOW</li>
<li>新建一个 Service, 在其 onCreate() 函数中添加如下代码：<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate();</div><div class="line"></div><div class="line">    <span class="comment">// WindowManager</span></div><div class="line">    <span class="keyword">final</span> WindowManager windowManager =</div><div class="line">        (WindowManager) getSystemService(Context.WINDOW_SERVICE);</div><div class="line"></div><div class="line">    <span class="comment">// 定义一个按钮</span></div><div class="line">    <span class="keyword">final</span> Button btn = <span class="keyword">new</span> Button(getBaseContext());</div><div class="line">    btn.setText(<span class="string">"Dismiss Me"</span>);</div><div class="line">    btn.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">            wm.removeView(btn);</div><div class="line">            stopSelf();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">// 布局参数</span></div><div class="line">    WindowManager.LayoutParams p = <span class="keyword">new</span> WindowManager.LayoutParams();</div><div class="line">    p.type = WindowManager.LayoutParams.TYPE_SYSTEM_ALERT;</div><div class="line">    p.gravity = Gravity.TOP;</div><div class="line">    p.width = WRAP_CONTENT;</div><div class="line">    p.height = WRAP_CONTENT;</div><div class="line">    p.x = <span class="number">0</span>;</div><div class="line">    p.y = <span class="number">0</span>;</div><div class="line">    p.flags |= WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;</div><div class="line">    </div><div class="line">    <span class="comment">// 添加按钮到 WindowManager</span></div><div class="line">    windowManager.addView(btn, p);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>当我们的 Service 被启动后，手机屏幕顶部就会显示一个按钮，点击此按钮后，它会消失。<br><img src="/images/window-manager/s1.png" alt=""></p>
<h2 id="二、如何定制悬浮窗？"><a href="#二、如何定制悬浮窗？" class="headerlink" title="二、如何定制悬浮窗？"></a>二、如何定制悬浮窗？</h2><p>从上述代码片段可知，定制悬浮窗的关键在于 WindowManager.LayoutParams 这个类，<br>我们来看看几个主要的成员。</p>
<ul>
<li>x, y<br>窗口的绝对位置（考虑gravity属性）</li>
<li>width, height<br>窗口的尺寸</li>
<li>gravity<br>窗口的布局方式</li>
<li><p>type<br>窗口的类型，值越大显示的位置越在上面</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// type 共分三大类:</span></div><div class="line"></div><div class="line"><span class="comment">/* --------- Application Window ---------- */</span></div><div class="line"><span class="comment">//  id 从 1 到 99, 目前有效值 1~3</span></div><div class="line"><span class="comment">//  Activity -&gt; TYPE_APPLICATION(2)（需要 token 设置成 Activity 的 token）</span></div><div class="line"></div><div class="line"><span class="comment">//开始应用程序窗口</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIRST_APPLICATION_WINDOW = <span class="number">1</span>;</div><div class="line"><span class="comment">//所有程序窗口的base窗口，其他应用程序窗口都显示在它上面</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_BASE_APPLICATION   = <span class="number">1</span>;</div><div class="line"><span class="comment">//普通应用程序窗口，token必须设置为Activity的token来指定窗口属于谁</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION        = <span class="number">2</span>;</div><div class="line"><span class="comment">//应用程序启动时所显示的窗口，应用自己不要使用这种类型，它被系统用来显示一些信息，直到应用程序可以开启自己的窗口为止</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_STARTING = <span class="number">3</span>;</div><div class="line"><span class="comment">//结束应用程序窗口</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LAST_APPLICATION_WINDOW = <span class="number">99</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* --------- Sub Window ---------- */</span></div><div class="line"><span class="comment">//  id 从 1000 到 1999, 目前有效值 1000~1005</span></div><div class="line"><span class="comment">// （与顶层窗口相关联，需将 token 设置成它所附着宿主窗口的 token）</span></div><div class="line"><span class="comment">//  PopupWindow -&gt; TYPE_APPLICATION_PANEL(1000)</span></div><div class="line"></div><div class="line"><span class="comment">//SubWindows子窗口，子窗口的Z序和坐标空间都依赖于他们的宿主窗口</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIRST_SUB_WINDOW = <span class="number">1000</span>;</div><div class="line"><span class="comment">// 面板窗口，显示于宿主窗口的上层</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_PANEL = FIRST_SUB_WINDOW;</div><div class="line"><span class="comment">//媒体窗口（例如视频），显示于宿主窗口下层</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_MEDIA = FIRST_SUB_WINDOW+<span class="number">1</span>;</div><div class="line"><span class="comment">//应用程序窗口的子面板，显示于所有面板窗口的上层</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_SUB_PANEL = FIRST_SUB_WINDOW+<span class="number">2</span>;</div><div class="line"><span class="comment">//对话框，类似于面板窗口，绘制类似于顶层窗口，而不是宿主的子窗口</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_ATTACHED_DIALOG = FIRST_SUB_WINDOW+<span class="number">3</span>;</div><div class="line"><span class="comment">//媒体信息，显示在媒体层和程序窗口之间，需要实现半透明效果</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_MEDIA_OVERLAY = FIRST_SUB_WINDOW+<span class="number">4</span>;</div><div class="line"><span class="comment">//子窗口结束</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LAST_SUB_WINDOW = <span class="number">1999</span>;</div><div class="line"></div><div class="line"><span class="comment">/* --------- System Window ---------- */</span></div><div class="line"><span class="comment">// id 从 2000 到 2999, 目前有效值 2000~2033</span></div><div class="line"><span class="comment">// 系统功能使用，不能用于应用程序，使用时需要特殊权限，它是特定的系统功能才能使用；</span></div><div class="line"></div><div class="line"><span class="comment">//系统窗口，非应用程序创建</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIRST_SYSTEM_WINDOW     = <span class="number">2000</span>;</div><div class="line"><span class="comment">//状态栏，只能有一个状态栏，位于屏幕顶端，其他窗口都位于它下方</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_STATUS_BAR         = FIRST_SYSTEM_WINDOW;</div><div class="line"><span class="comment">//搜索栏，只能有一个搜索栏，位于屏幕上方</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_SEARCH_BAR         = FIRST_SYSTEM_WINDOW+<span class="number">1</span>;</div><div class="line"><span class="comment">//电话窗口，它用于电话交互（特别是呼入），置于所有应用程序之上，状态栏之下</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_PHONE              = FIRST_SYSTEM_WINDOW+<span class="number">2</span>;</div><div class="line"><span class="comment">//系统提示，出现在应用程序窗口之上</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_SYSTEM_ALERT       = FIRST_SYSTEM_WINDOW+<span class="number">3</span>;</div><div class="line"><span class="comment">//锁屏窗口</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_KEYGUARD           = FIRST_SYSTEM_WINDOW+<span class="number">4</span>;</div><div class="line"><span class="comment">//信息窗口，用于显示Toast</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_TOAST              = FIRST_SYSTEM_WINDOW+<span class="number">5</span>;</div><div class="line"><span class="comment">//系统顶层窗口，显示在其他一切内容之上，此窗口不能获得输入焦点，否则影响锁屏</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_SYSTEM_OVERLAY     = FIRST_SYSTEM_WINDOW+<span class="number">6</span>;</div><div class="line"><span class="comment">//电话优先，当锁屏时显示，此窗口不能获得输入焦点，否则影响锁屏</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_PRIORITY_PHONE     = FIRST_SYSTEM_WINDOW+<span class="number">7</span>;</div><div class="line"><span class="comment">//系统对话框</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_SYSTEM_DIALOG      = FIRST_SYSTEM_WINDOW+<span class="number">8</span>;</div><div class="line"><span class="comment">//锁屏时显示的对话框</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_KEYGUARD_DIALOG    = FIRST_SYSTEM_WINDOW+<span class="number">9</span>;</div><div class="line"><span class="comment">//系统内部错误提示，显示于所有内容之上</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_SYSTEM_ERROR       = FIRST_SYSTEM_WINDOW+<span class="number">10</span>;</div><div class="line"><span class="comment">//内部输入法窗口，显示于普通UI之上，应用程序可重新布局以免被此窗口覆盖</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_INPUT_METHOD       = FIRST_SYSTEM_WINDOW+<span class="number">11</span>;</div><div class="line"><span class="comment">//内部输入法对话框，显示于当前输入法窗口之上</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_INPUT_METHOD_DIALOG= FIRST_SYSTEM_WINDOW+<span class="number">12</span>;</div><div class="line"><span class="comment">//墙纸窗口</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_WALLPAPER          = FIRST_SYSTEM_WINDOW+<span class="number">13</span>;</div><div class="line"><span class="comment">//状态栏的滑动面板</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_STATUS_BAR_PANEL   = FIRST_SYSTEM_WINDOW+<span class="number">14</span>;</div><div class="line"><span class="comment">//安全系统覆盖窗口，这些窗户必须不带输入焦点，否则会干扰键盘</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_SECURE_SYSTEM_OVERLAY = FIRST_SYSTEM_WINDOW+<span class="number">15</span>;</div><div class="line"><span class="comment">//拖放伪窗口，只有一个阻力层(最多)，它被放置在所有其他窗口上面</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_DRAG               = FIRST_SYSTEM_WINDOW+<span class="number">16</span>;</div><div class="line"><span class="comment">//状态栏下拉面板</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_STATUS_BAR_SUB_PANEL = FIRST_SYSTEM_WINDOW+<span class="number">17</span>;</div><div class="line"><span class="comment">//鼠标指针</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_POINTER = FIRST_SYSTEM_WINDOW+<span class="number">18</span>;</div><div class="line"><span class="comment">//导航栏(有别于状态栏时)</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_NAVIGATION_BAR = FIRST_SYSTEM_WINDOW+<span class="number">19</span>;</div><div class="line"><span class="comment">//音量级别的覆盖对话框，显示当用户更改系统音量大小</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_VOLUME_OVERLAY = FIRST_SYSTEM_WINDOW+<span class="number">20</span>;</div><div class="line"><span class="comment">//起机进度框，在一切之上</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_BOOT_PROGRESS = FIRST_SYSTEM_WINDOW+<span class="number">21</span>;</div><div class="line"><span class="comment">//假窗，消费导航栏隐藏时触摸事件</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_HIDDEN_NAV_CONSUMER = FIRST_SYSTEM_WINDOW+<span class="number">22</span>;</div><div class="line"><span class="comment">//梦想(屏保)窗口，略高于键盘</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_DREAM = FIRST_SYSTEM_WINDOW+<span class="number">23</span>;</div><div class="line"><span class="comment">//导航栏面板(不同于状态栏的导航栏)</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_NAVIGATION_BAR_PANEL = FIRST_SYSTEM_WINDOW+<span class="number">24</span>;</div><div class="line"><span class="comment">//universe背后真正的窗户</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_UNIVERSE_BACKGROUND = FIRST_SYSTEM_WINDOW+<span class="number">25</span>;</div><div class="line"><span class="comment">//显示窗口覆盖，用于模拟辅助显示设备</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_DISPLAY_OVERLAY = FIRST_SYSTEM_WINDOW+<span class="number">26</span>;</div><div class="line"><span class="comment">//放大窗口覆盖，用于突出显示的放大部分可访问性放大时启用</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_MAGNIFICATION_OVERLAY = FIRST_SYSTEM_WINDOW+<span class="number">27</span>;</div><div class="line"><span class="comment">//......</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_KEYGUARD_SCRIM           = FIRST_SYSTEM_WINDOW+<span class="number">29</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_PRIVATE_PRESENTATION = FIRST_SYSTEM_WINDOW+<span class="number">30</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_VOICE_INTERACTION = FIRST_SYSTEM_WINDOW+<span class="number">31</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_ACCESSIBILITY_OVERLAY = FIRST_SYSTEM_WINDOW+<span class="number">32</span>;</div><div class="line"><span class="comment">//系统窗口结束</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LAST_SYSTEM_WINDOW      = <span class="number">2999</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>flags<br>flags 和 type 可以共同决定 Window 的表示和行为</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// FLAG_ALLOW_LOCK_WHILE_SCREEN_ON:</span></div><div class="line"><span class="comment">// 当窗口可见时，允计锁屏界面出现。</span></div><div class="line"></div><div class="line"><span class="comment">// FLAG_DIM_BEHIND:</span></div><div class="line"><span class="comment">// 窗口之后的内容变暗</span></div><div class="line"></div><div class="line"><span class="comment">// FLAG_NOT_FOCUSABLE:</span></div><div class="line"><span class="comment">// 不能获得按键输入焦点，所以不能向它发送按键或按钮事件。那些事件将发送给它后面的可以获得焦点的窗口。</span></div><div class="line"><span class="comment">// 此选项还会设置 FLAG_NOT_TOUCH_MODAL 选项。设置此选项，意味着窗口不能与软输入法进行交互，</span></div><div class="line"><span class="comment">// 所以它的 Z 序独立于任何活动的输入法（它可以全屏显示，如果需要的话，可覆盖输入法窗口）。</span></div><div class="line"><span class="comment">// 要修改这一行为，可参考 FLAG_ALT_FOCUSALBE_IM 选项。</span></div><div class="line"></div><div class="line"><span class="comment">// FLAG_NOT_TOUCHABLE:</span></div><div class="line"><span class="comment">// 不接受触摸屏事件</span></div><div class="line"></div><div class="line"><span class="comment">// FLAG_NOT_TOUCH_MODAL:</span></div><div class="line"><span class="comment">// 当窗口可以获得焦点（没有设置 FLAG_NOT_FOCUSALBE 选项）时，仍然将窗口范围之外的点设备事件</span></div><div class="line"><span class="comment">//（鼠标、触摸屏）发送给后面的窗口处理。否则它将独占所有的点设备事件，而不管它们是不是发生在窗口范围之内。</span></div><div class="line"></div><div class="line"><span class="comment">// FLAG_TOUCHABLE_WHEN_WAKING:</span></div><div class="line"><span class="comment">// 如果设置了这个标志，当设备休眠时，点击触摸屏，设备将收到这个第一触摸事件。</span></div><div class="line"><span class="comment">// 通常第一触摸事件被系统所消耗，用户不会看到他们点击屏幕有什么反应。</span></div><div class="line"></div><div class="line"><span class="comment">// FLAG_KEEP_SCREEN_ON</span></div><div class="line"><span class="comment">// 当此窗口为用户可见时，保持设备常开，并保持亮度不变。</span></div><div class="line"></div><div class="line"><span class="comment">// FLAG_LAYOUT_IN_SCREEN:</span></div><div class="line"><span class="comment">// 窗口占满整个屏幕，忽略周围的装饰边框（例如状态栏）。此窗口需考虑到装饰边框的内容。</span></div><div class="line"></div><div class="line"><span class="comment">// FLAG_LAYOUT_NO_LIMITS:</span></div><div class="line"><span class="comment">// 允许窗口扩展到屏幕之外</span></div><div class="line"></div><div class="line"><span class="comment">// FLAG_FULLSCREEN:</span></div><div class="line"><span class="comment">// 窗口显示时，隐藏所有的屏幕装饰（例如状态条）。使窗口占用整个显示区域。</span></div><div class="line"></div><div class="line"><span class="comment">// FLAG_FORCE_NOT_FULLSCREEN:</span></div><div class="line"><span class="comment">// 此选项将覆盖 FLAG_FULLSCREEN 选项，并强制屏幕装饰（如状态条）弹出。</span></div><div class="line"></div><div class="line"><span class="comment">// FLAG_SECURE:</span></div><div class="line"><span class="comment">// 不允许屏幕截图</span></div><div class="line"></div><div class="line"><span class="comment">// FLAG_SCALED:</span></div><div class="line"><span class="comment">// 一种特殊模式，布局参数用于指示显示比例</span></div><div class="line"></div><div class="line"><span class="comment">// FLAG_IGNORE_CHEEK_PRESSES:</span></div><div class="line"><span class="comment">// 当屏幕有可能贴着脸时，这一选项可防止面颊对屏幕造成误操作</span></div><div class="line"></div><div class="line"><span class="comment">// FLAG_LAYOUT_INSET_DECOR:</span></div><div class="line"><span class="comment">// 当请求布局时，你的窗口可能出现在状态栏的上面或下面，从而造成遮挡。</span></div><div class="line"><span class="comment">// 当设置这一选项后，窗口管理器将确保窗口内容不会被装饰条（状态栏）盖住。 </span></div><div class="line"></div><div class="line"><span class="comment">// public static final int FLAG_ALT_FOCUSABLE_IM:</span></div><div class="line"><span class="comment">// 如果同时设置了FLAG_NOT_FOCUSABLE选项和本选项，窗口将能够与输入法交互，允许输入法窗口覆盖； </span></div><div class="line"><span class="comment">// 如果FLAG_NOT_FOCUSABLE没有设置而设置了本选项，窗口不能与输入法交互，可以覆盖输入法窗口。 </span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// FLAG_WATCH_OUTSIDE_TOUCH:</span></div><div class="line"><span class="comment">// 如果你设置了FLAG_NOT_TOUCH_MODAL，那么当触屏事件发生在窗口之外时，</span></div><div class="line"><span class="comment">// 可以通过设置此标志接收到一个MotionEvent.ACTION_OUTSIDE事件。</span></div><div class="line"><span class="comment">// 注意，你不会收到完整的down/move/up事件，只有第一次down事件时可以收到ACTION_OUTSIDE。 </span></div><div class="line"></div><div class="line"><span class="comment">// FLAG_SHOW_WHEN_LOCKED:</span></div><div class="line"><span class="comment">// 当屏幕锁定时，窗口可以被看到。这使得应用程序窗口优先于锁屏界面。</span></div><div class="line"><span class="comment">// 可配合 FLAG_KEEP_SCREEN_ON 选项点亮屏幕并直接显示在锁屏界面之前。</span></div><div class="line"><span class="comment">// 可使用FLAG_DISMISS_KEYGUARD选项直接解除非加锁的锁屏状态。此选项只用于最顶层的全屏幕窗口。 </span></div><div class="line"></div><div class="line"><span class="comment">// FLAG_SHOW_WALLPAPER:</span></div><div class="line"><span class="comment">// 请求系统墙纸显示在你的窗口后面。窗口必须是半透明的。</span></div><div class="line"></div><div class="line"><span class="comment">// FLAG_TURN_SCREEN_ON:</span></div><div class="line"><span class="comment">// 窗口一旦显示出来，系统将点亮屏幕，正如用户唤醒设备那样。</span></div><div class="line"></div><div class="line"><span class="comment">// FLAG_DISMISS_KEYGUARD:</span></div><div class="line"><span class="comment">// 解除锁屏。只有锁屏界面不是加密的才能解锁。</span></div><div class="line"><span class="comment">// 如果锁屏界面是加密的，那么用户解锁之后才能看到此窗口，除非设置了FLAG_SHOW_WHEN_LOCKED选项。 </span></div><div class="line"></div><div class="line"><span class="comment">// FLAG_SPLIT_TOUCH:</span></div><div class="line"></div><div class="line"><span class="comment">// FLAG_HARDWARE_ACCELERATED:</span></div><div class="line"><span class="comment">// 硬件加速</span></div><div class="line"></div><div class="line"><span class="comment">// FLAG_LOCAL_FOCUS_MODE:</span></div><div class="line"></div><div class="line"><span class="comment">// FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS:</span></div></pre></td></tr></table></figure>
<p>示例：</p>
<ul>
<li>使悬浮窗可以覆盖通知栏<br>type = TYPE_SYSTEM_ERROR<br>flags = FLAG_LAYOUT_IN_SCREEN</li>
<li>使悬浮窗不遮挡输入法<br>FLAG_ALT_FOCUSABLE_IM</li>
<li>使悬浮窗不可点击（可以获得焦点，会拦截 Back, Home 键）<br>FLAG_NOT_TOUCHABLE</li>
<li>使悬浮窗不可获得焦点（不拦截 Back, Home 键）<br>FLAG_NOT_FOCUSABLE</li>
</ul>
</li>
</ul>
<h2 id="三、悬浮窗是如何显示到屏幕上的"><a href="#三、悬浮窗是如何显示到屏幕上的" class="headerlink" title="三、悬浮窗是如何显示到屏幕上的?"></a>三、悬浮窗是如何显示到屏幕上的?</h2><p>我们知道视图是通过 WindowManager 添加到屏幕上的，所以第一个要了解的类便是 WindowManager。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// android.view.WindowManager</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WindowManager</span> <span class="keyword">extends</span> <span class="title">ViewManager</span> </span>&#123;</div><div class="line">    <span class="comment">// 获取 Display</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Display <span class="title">getDefaultDisplay</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 立即删除 View</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeViewImmediate</span><span class="params">(View view)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们看到 WindowManager 继承自 ViewManager， 有一个获取 DefaultDisplay 的方法和删除 View 的方法；<br>再来看看 ViewManager 的代码：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// android.view.ViewManager</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ViewManager</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span>(<span class="params">View view, ViewGroup.LayoutParams <span class="keyword">params</span></span>)</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span>(<span class="params">View view, ViewGroup.LayoutParams <span class="keyword">params</span></span>)</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span>(<span class="params">View view</span>)</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>非常简洁的三个函数：添加视图，更新视图，删除视图。<br>如果再查看一个 ViewManager 的其它实现类，还会发现 ViewGroup 也实现了这个接口。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewGroup</span> <span class="keyword">extends</span> <span class="title">View</span> <span class="title">implements</span> <span class="title">ViewParent</span>, <span class="title">ViewManager</span> </span>&#123;...&#125;</div></pre></td></tr></table></figure></p>
<p>我们再来看看 WindowManager 的实现者是谁？<br> <figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="section">Log.d("wm", windowManager.getClass().getName());</span></div><div class="line">--------------------------------------------------</div><div class="line">D/wm      (28372): android.view.WindowManagerImpl</div></pre></td></tr></table></figure></p>
<p>原来是 WindowManagerImpl，如果有同学觉见得打 Log 的方式太偷懒了，可以阅读<a href="http://erhu.party/2016/09/29/get-system-service/">这篇文章</a>来了解 getSystemService(…) 的实现原理。</p>
<p>那我们就来看看 WindowManagerImpl 的 addView(…), updateViewLayout(…), removeView(…) 这三个函数吧：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// android.view.WindowManagerImpl</span></div><div class="line">...</div><div class="line"><span class="keyword">private</span> final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();</div><div class="line">...</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span>(<span class="params">@NonNull View view, @NonNull ViewGroup.LayoutParams <span class="keyword">params</span></span>) </span>&#123;</div><div class="line">    applyDefaultToken(<span class="keyword">params</span>);</div><div class="line">    mGlobal.addView(view, <span class="keyword">params</span>, mDisplay, mParentWindow);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@<span class="function">Override</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span>(<span class="params">@NonNull View view, @NonNull ViewGroup.LayoutParams <span class="keyword">params</span></span>) &#123;</div><div class="line">    applyDefaultToken(<span class="keyword">params</span>);</div><div class="line">    mGlobal.updateViewLayout(view, <span class="keyword">params</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@<span class="function">Override</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span>(<span class="params">View view</span>) &#123;</div><div class="line">    mGlobal.removeView(view, <span class="literal">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这几个函数无一例外地将实现都转移给了 WindowManagerGlobal:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// android.view.WindowManagerGlobal</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowManagerGlobal</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">WindowManagerGlobal</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WindowManagerGlobal <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</div><div class="line">            <span class="keyword">if</span> (sDefaultWindowManager == <span class="keyword">null</span>) &#123;</div><div class="line">                sDefaultWindowManager = <span class="keyword">new</span> WindowManagerGlobal();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> sDefaultWindowManager;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>毫无疑问，WindowManagerGlobal 使用了单例，所以<strong>一个进程中最多只有一个 WindowManager，所有 WindowManager 实例都是这个 WindowManagerGlobal 实例的代理</strong>。</p>
<p>到此，我们对 WindowManager 的结构体系便有了一个概括的了解：<br><img src="/images/window-manager/window-manager-structure.png" alt=""></p>
<h2 id="四、-WindowManagerGlobal-详解"><a href="#四、-WindowManagerGlobal-详解" class="headerlink" title="四、 WindowManagerGlobal 详解"></a>四、 WindowManagerGlobal 详解</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;View&gt; mViews = <span class="keyword">new</span> ArrayList&lt;View&gt;();</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;ViewRootImpl&gt; mRoots = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;WindowManager.LayoutParams&gt; mParams = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArraySet&lt;View&gt; mDyingViews = <span class="keyword">new</span> ArraySet&lt;&gt;();</div></pre></td></tr></table></figure>
<p>WindowManagerGlobal 有 4 个重要的集合：</p>
<ul>
<li>mView : 根视图集合</li>
<li>mRoots : ViewRootImpl 集合</li>
<li>mParams : 根视图的布局的集合</li>
<li>mDyingViews : 要移除和根视图的集合</li>
</ul>
<p>我们先来分析 添加、删除、更新 3 种操作对这 4 个集合的影响。</p>
<h3 id="1-添加视图"><a href="#1-添加视图" class="headerlink" title="1. 添加视图"></a>1. 添加视图</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// android.view.WindowManagerGlobal</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123;</div><div class="line">   ...</div><div class="line">   <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</div><div class="line">   ...</div><div class="line">   ViewRootImpl root;</div><div class="line">   View panelParentView = <span class="keyword">null</span>;</div><div class="line">   synchronized (mLock) &#123;</div><div class="line">       ...</div><div class="line">       <span class="keyword">int</span> <span class="keyword">index</span> = findViewLocked(view, <span class="keyword">false</span>);</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">index</span> &gt;= <span class="number">0</span>) &#123;</div><div class="line">           <span class="keyword">if</span> (mDyingViews.contains(view)) &#123;</div><div class="line">               <span class="comment">// Don't wait for MSG_DIE to make it's way through root's queue.</span></div><div class="line">               mRoots.get(<span class="keyword">index</span>).doDie();</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               ...</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       ...</div><div class="line">       root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</div><div class="line">       view.setLayoutParams(wparams);</div><div class="line">       mViews.add(view);</div><div class="line">       mRoots.add(root);</div><div class="line">       mParams.add(wparams);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       root.setView(view, wparams, panelParentView);</div><div class="line">   &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</div><div class="line">       <span class="comment">// BadTokenException or InvalidDisplayException, clean up.</span></div><div class="line">       synchronized (mLock) &#123;</div><div class="line">           <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">index</span> = findViewLocked(view, <span class="keyword">false</span>);</div><div class="line">           <span class="keyword">if</span> (<span class="keyword">index</span> &gt;= <span class="number">0</span>) &#123;</div><div class="line">               removeViewLocked(<span class="keyword">index</span>, <span class="keyword">true</span>);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">throw</span> e;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>添加视图时，做了以下几件事：</p>
<ol>
<li>将 view, viewRootImpl, layoutParams 分别添加到对应的集合中;</li>
<li>将 layoutParams 设置给 view;</li>
<li>将 view 设置给 viewRootImpl;</li>
</ol>
<h3 id="2-更新视图"><a href="#2-更新视图" class="headerlink" title="2. 更新视图"></a>2. 更新视图</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// android.view.WindowManagerGlobal</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> updateViewLayout(View view, ViewGroup.LayoutParams params) &#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;</div><div class="line">    view.setLayoutParams(wparams);</div><div class="line">    synchronized (mLock) &#123;</div><div class="line">        <span class="keyword">int</span> <span class="keyword">index</span> = findViewLocked(view, <span class="keyword">true</span>);</div><div class="line">        ViewRootImpl root = mRoots.get(<span class="keyword">index</span>);</div><div class="line">        mParams.remove(<span class="keyword">index</span>);</div><div class="line">        mParams.add(<span class="keyword">index</span>, wparams);</div><div class="line">        root.setLayoutParams(wparams, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>更新视图比较简单</p>
<ol>
<li>设置 layoutParams 给 view;</li>
<li>更新 mParams 集合中对应的 layoutParams;</li>
<li>更新 对应 viewRootImpl 的 laoutParams;</li>
</ol>
<h3 id="3-删除视图"><a href="#3-删除视图" class="headerlink" title="3. 删除视图"></a>3. 删除视图</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// android.view.WindowManagerGlobal</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> removeView(View view, <span class="keyword">boolean</span> immediate) &#123;</div><div class="line">    ...</div><div class="line">    synchronized (mLock) &#123;</div><div class="line">        <span class="keyword">int</span> <span class="keyword">index</span> = findViewLocked(view, <span class="keyword">true</span>);</div><div class="line">        View curView = mRoots.get(<span class="keyword">index</span>).getView();</div><div class="line">        removeViewLocked(<span class="keyword">index</span>, immediate);</div><div class="line">        <span class="keyword">if</span> (curView == view) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到，删除视图最终交给了 removeViewLocked 函数:<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// android.view.WindowManagerGlobal</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> removeViewLocked(<span class="keyword">int</span> <span class="keyword">index</span>, <span class="keyword">boolean</span> immediate) &#123;</div><div class="line">    ViewRootImpl root = mRoots.get(<span class="keyword">index</span>);</div><div class="line">    View view = root.getView();</div><div class="line">    ...</div><div class="line">    <span class="comment">// 检查是否需要延迟删除</span></div><div class="line">    <span class="keyword">boolean</span> deferred = root.die(immediate);</div><div class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</div><div class="line">        view.assignParent(<span class="keyword">null</span>);</div><div class="line">        <span class="keyword">if</span> (deferred) &#123;</div><div class="line">            mDyingViews.add(view);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>removeViewLocked 函数会调用 ViewRootImpl 的 die() 函数，该函数返回一个 boolean 值，标识是否需要延迟删除？如果需要延迟，则将 view 加入 mDyingViews 这个集合中。</p>
<p>接着我们看看 ViewRootImpl 的 die 函数:<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// android.view.ViewRootImpl</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">die</span><span class="params">(<span class="keyword">boolean</span> immediate)</span> </span>&#123;</div><div class="line">    <span class="comment">// Make sure we do execute immediately if we are in the middle of a traversal or the damage</span></div><div class="line">    <span class="comment">// done by dispatchDetachedFromWindow will cause havoc on return.</span></div><div class="line">    <span class="keyword">if</span> (immediate &amp;&amp; !mIsInTraversal) &#123;</div><div class="line">        doDie();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!mIsDrawing) &#123;</div><div class="line">        destroyHardwareRenderer();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    mHandler.sendEmptyMessage(MSG_DIE);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">case</span> MSG_DIE:</div><div class="line">        doDie();</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们看到，所谓的延迟删除，其实就是使用了 Handler 消息队列机制，来调用 doDie() 函数；<br>如果是非延迟删除，则立即调用 doDie() 函数:</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// android.view.ViewRootImpl</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doDie</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 必须在主线程</span></div><div class="line">    checkThread();</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (mRemoved) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        mRemoved = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (mAdded) &#123;</div><div class="line">            <span class="comment">// 发送 DetachedFromWindow 消息事件</span></div><div class="line">            dispatchDetachedFromWindow();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ...</div><div class="line">        mAdded = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    WindowManagerGlobal.getInstance().doRemoveView(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>doDie() 函数会发送 DetachedFromWindow 消息给 View；然后调用 WindowManagerGlobal 的 doRemoveView() 函数：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// android.view.WindowManagerGlobal</span></div><div class="line"><span class="keyword">void</span> doRemoveView(ViewRootImpl root) &#123;</div><div class="line">    synchronized (mLock) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">index</span> = mRoots.indexOf(root);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">index</span> &gt;= <span class="number">0</span>) &#123;</div><div class="line">            mRoots.remove(<span class="keyword">index</span>);</div><div class="line">            mParams.remove(<span class="keyword">index</span>);</div><div class="line">            <span class="keyword">final</span> View view = mViews.remove(<span class="keyword">index</span>);</div><div class="line">            mDyingViews.remove(view);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>doRemoveView() 函数的功能一目了然，即从 mRoots, mParams, mDyingViews 中将 数据移除掉。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ol>
<li>使用悬浮窗时，要声明权限（个别机型有单独的悬浮窗权限管理，如小米）；</li>
<li>悬浮窗是使用 WindowManager 添加到屏幕上的，WindowManaget.LayoutParams 可以定制悬浮窗的表现和行为；</li>
<li>WindowManager 的实际实现是 WindowManagerGlobal;</li>
<li>WindowManagerGlobal 使用 4 个列表保存了窗口的关键数据，并配合 ViewRootImpl 类完成窗口的添加、更新、删除操作；</li>
<li>关于 WindowManager 分析的部分不局限于悬浮窗，它也是整个 Android 系统的窗口管理器。</li>
</ol>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://erhu.party/2016/09/29/window-manager/" data-id="ciuzk2pip0003c0qa5jv75okb" class="article-share-link">分享到</a><div class="tags"><a href="/tags/android/">android</a></div><div class="post-nav"><a href="/2016/09/29/get-system-service/" class="pre">追踪 getSystemService(...)</a><a href="/2016/09/28/camera-3/" class="next">我的第三台相机</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/camera/" style="font-size: 15px;">camera</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/besier/" style="font-size: 15px;">besier</a> <a href="/tags/技术分享/" style="font-size: 15px;">技术分享</a> <a href="/tags/photography/" style="font-size: 15px;">photography</a> <a href="/tags/scinece/" style="font-size: 15px;">scinece</a> <a href="/tags/emacs/" style="font-size: 15px;">emacs</a> <a href="/tags/todo/" style="font-size: 15px;">todo</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/11/01/fantastic-ppt/">技术分享圆满成功</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/18/photograph001/">摄影作品001</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/16/besier/">贝塞尔曲线</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/29/get-system-service/">追踪 getSystemService(...)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/29/window-manager/">从源码角度解析悬浮窗</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/28/camera-3/">我的第三台相机</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/26/huan-qiu-ke-xue/">环球科学</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/22/my-first-emacs-function/">我的第一个Emacs函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/01/deep-set-content-view-2/">深入理解View(二)：Activity的页面结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/01/deep-set-content-view/">深入理解View(一)：从setContentView谈起</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">四十岁退休.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>