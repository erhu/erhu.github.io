<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Javassist 使用指南（三） | 四十岁退休</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Javassist 使用指南（三）</h1><a id="logo" href="/.">四十岁退休</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Javassist 使用指南（三）</h1><div class="post-meta">Nov 23, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p><strong>本文译自：</strong> <a href="https://github.com/jboss-javassist/javassist/wiki/Tutorial-3" target="_blank" rel="external">Javassist Tutorial-3</a><br><strong>原作者：</strong> Shigeru Chiba<br><strong>完成时间：</strong>2016年11月</p>
<h2 id="5-字节码操作"><a href="#5-字节码操作" class="headerlink" title="5. 字节码操作"></a>5. 字节码操作</h2><p>Javassist 还提供了用于直接编辑类文件的低级级 API。 使用此 API之前，你需要详细了解Java 字节码和类文件格式，因为它允许你对类文件进行任意修改。</p>
<p>如果你只想生成一个简单的类文件，使用<code>javassist.bytecode.ClassFileWriter</code>就足够了。 它比<code>javassist.bytecode.ClassFile</code>更快而且更小。</p>
<h3 id="获取-ClassFile-对象"><a href="#获取-ClassFile-对象" class="headerlink" title="获取 ClassFile 对象"></a>获取 ClassFile 对象</h3><p>javassist.bytecode.ClassFile 对象表示类文件。要获得这个对象，应该调用 CtClass 中的 getClassFile() 方法。<br>你也可以直接从类文件构造 javassist.bytecode.ClassFile 对象。 例如：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BufferedInputStream fin</div><div class="line">    = new BufferedInputStream(<span class="name">new</span> FileInputStream(<span class="string">"Point.class"</span>))<span class="comment">;</span></div><div class="line">ClassFile cf = new ClassFile(<span class="name">new</span> DataInputStream(<span class="name">fin</span>))<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>这代码段从 Point.class 创建一个 ClassFile 对象。<br>ClassFile 对象可以写回类文件。ClassFile 的 write() 将类文件的内容写入给定的 DataOutputStream。</p>
<h3 id="5-2-添加和删除成员"><a href="#5-2-添加和删除成员" class="headerlink" title="5.2 添加和删除成员"></a>5.2 添加和删除成员</h3><p>ClassFile 提供了 addField()，addMethod() 和 addAttribute()，来向类添加字段、方法和类文件属性。</p>
<p>注意，FieldInfo，MethodInfo 和 AttributeInfo 对象包括到 ConstPool（常量池表）对象的链接。 ConstPool 对象必须对 ClassFile 对象和添加到该 ClassFile 对象的 FieldInfo（或MethodInfo 等）对象是通用的。 换句话说，FieldInfo（或MethodInfo等）对象不能在不同的ClassFile 对象之间共享。</p>
<p>要从 ClassFile 对象中删除字段或方法，必须首先获取包含该类的所有字段的 java.util.List 对象。 getFields() 和 getMethods() 返回列表。可以通过在List对象上调用 remove() 来删除字段或方法。可以以类似的方式去除属性。在 FieldInfo 或 MethodInfo 中调用 getAttributes() 以获取属性列表，并从列表中删除一个。</p>
<h3 id="5-3-遍历方法体"><a href="#5-3-遍历方法体" class="headerlink" title="5.3 遍历方法体"></a>5.3 遍历方法体</h3><p>使用 CodeIterator 可以检查方法体中的每个字节码指令，要获得 CodeIterator 对象，参考以下代码：<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ClassFile <span class="built_in">cf</span> = ... ;</div><div class="line">MethodInfo minfo = <span class="built_in">cf</span>.getMethod(<span class="string">"move"</span>);    // we <span class="built_in">assume</span> move <span class="built_in">is</span> <span class="keyword">not</span> overloaded.</div><div class="line">CodeAttribute ca = minfo.getCodeAttribute();</div><div class="line">CodeIterator i = ca.iterator();</div></pre></td></tr></table></figure></p>
<p>CodeIterator 对象允许你逐个访问每个字节码指令。下面展示了一部分 CodeIterator 中声明的方法：</p>
<ul>
<li>void begin（）<br>移动到第一条指令。</li>
<li>void move（int index）<br>移动到指定位置的指令。</li>
<li>boolean hasNext（）<br>是否有下一条指定</li>
<li>int next（）<br>返回下一条指令的索引。注意，它不返回下一条指令的操作码。</li>
<li>int byteAt（int index）<br>返回索引处的无符号8位整数。</li>
<li>int u16bitAt（int index）<br>返回索引处的无符号16位整数。</li>
<li>int write（byte [] code，int index）<br>在索引处写入字节数组。</li>
<li>void insert（int index，byte [] code）<br>在索引处插入字节数组。自动调整分支偏移量。</li>
</ul>
<p>以下代码段打印了方法体中所有的指令：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CodeIterator ci = ... ;</div><div class="line"><span class="keyword">while</span> (ci.hasNext()) &#123;</div><div class="line">    <span class="built_in">int</span> <span class="built_in">index</span> = ci.next();</div><div class="line">    <span class="built_in">int</span> op = ci.byteAt(<span class="built_in">index</span>);</div><div class="line">    System.<span class="keyword">out</span>.println(Mnemonic.OPCODE[op]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="5-4-生成字节码序列"><a href="#5-4-生成字节码序列" class="headerlink" title="5.4 生成字节码序列"></a>5.4 生成字节码序列</h3><p> <code>Bytecode</code> 对象表示字节码指令序列。它是一个可扩展的字节码数组。<br>以下是示例代码段：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ConstPool cp = ...<span class="comment">;    // constant pool table</span></div><div class="line"><span class="keyword">Bytecode </span><span class="keyword">b </span>= new <span class="keyword">Bytecode(cp, </span><span class="number">1</span>, <span class="number">0</span>)<span class="comment">;</span></div><div class="line"><span class="keyword">b.addIconst(3);</span></div><div class="line"><span class="keyword">b.addReturn(CtClass.intType);</span></div><div class="line">CodeAttribute ca = <span class="keyword">b.toCodeAttribute();</span></div></pre></td></tr></table></figure>
<p>这段代码产生以下序列的代码属性：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ico<span class="symbol">nst_3</span></div><div class="line">iretur<span class="symbol">n</span></div></pre></td></tr></table></figure></p>
<p>您还可以通过调用 Bytecode 中的 get() 方法来获取包含此序列的字节数组。获得的数组可以插入另一个代码属性。<br>Bytecode 提供了许多方法来添加特定的指令，例如使用 addOpcode() 添加一个 8 位操作码，使用 addIndex() 用于添加一个索引。每个操作码的值定义在 Opcode 接口中。<br>addOpcode() 和添加特定指令的方法，将自动维持最大堆栈深度，除非控制流没有分支。可以通过调用 Bytecode 的 getMaxStack() 方法来获得这个深度。它也反映在从 Bytecode对象构造的 CodeAttribute 对象上。要重新计算方法体的最大堆栈深度，可以调用 CodeAttribute 的 computeMaxStack() 方法。</p>
<h3 id="5-5-注释（元标签）"><a href="#5-5-注释（元标签）" class="headerlink" title="5.5 注释（元标签）"></a>5.5 注释（元标签）</h3><p>注释作为运行时不可见（或可见）的注记属性，存储在类文件中。调用 getAttribute（AnnotationsAttribute.invisibleTag）方法，可以从 ClassFile，MethodInfo 或 FieldInfo 中获取注记属性。更多信息，请参阅 <code>javassist.bytecode.AnnotationsAttribute</code> 和<code>javassist.bytecode.annotation</code> 包的 javadoc 手册。</p>
<p>Javassist还允许您通过更高级别的API访问注释。 如果要通过CtClass访问注释，请在CtClass或CtBehavior中调用getAnnotations（）。</p>
<h2 id="6-泛型"><a href="#6-泛型" class="headerlink" title="6. 泛型"></a>6. 泛型</h2><p>Javassist 的低级别 API 完全支持 Java 5 引入的泛型。但是，高级别的API（如CtClass）不直接支持泛型。</p>
<p>Java 的泛型是通过擦除技术实现。 编译后，所有类型参数都将被删除。 例如，假设您的源代码声明一个参数化类型 Vector<string>：<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Vector</span>&lt;<span class="keyword">String</span>&gt; v = <span class="keyword">new</span> <span class="built_in">Vector</span>&lt;<span class="keyword">String</span>&gt;();</div><div class="line">  :</div><div class="line"><span class="keyword">String</span> s = v.get(<span class="number">0</span>);</div></pre></td></tr></table></figure></string></p>
<p>编译后的字节码等价于以下代码：<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Vector</span> v = <span class="keyword">new</span> <span class="built_in">Vector</span>();</div><div class="line">  :</div><div class="line"><span class="keyword">String</span> s = (<span class="keyword">String</span>)v.get(<span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>因此，在编写字节码变换器时，您可以删除所有类型参数，因为 Javassist 的编译器不支持泛型。如果源代码使用 Javassist 编译，例如通过 CtMethod.make()，源代码必须显式类型转换。如果源代码由常规 Java 编译器（如javac）编译，则不需要做类型转换。</p>
<p>例如，如果你有一个类：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public class Wrapper&lt;<span class="built_in">T</span>&gt; &#123;</div><div class="line">  <span class="built_in">T</span> <span class="built_in">value</span>;</div><div class="line">  public Wrapper(<span class="built_in">T</span> <span class="built_in">t</span>) &#123; <span class="built_in">value</span> = <span class="built_in">t</span>; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>并想添加一个接口 Getter<t> 到类 Wrapper<t>：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Getter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">  T <span class="keyword">get</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure></t></t></p>
<p>那么你真正要添加的接口其实是Getter（将类型参数<t>掉落），最后你添加到 Wrapper 类的方法是这样的：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">value</span>; &#125;</div></pre></td></tr></table></figure></t></p>
<p>注意，不需要类型参数。 由于 get 返回一个 Object，如果源代码是由 Javassist 编译的，那么在调用方需要进行显式类型转换。 例如，如果类型参数 T 是 String，则必须插入（String），如下所示：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Wrapper w = ...</div><div class="line"><span class="keyword">String</span> s = (<span class="keyword">String</span>)w.<span class="built_in">get</span>();</div></pre></td></tr></table></figure></p>
<h2 id="7-可变参数"><a href="#7-可变参数" class="headerlink" title="7.可变参数"></a>7.可变参数</h2><p>目前，Javassist 不直接支持可变参数。 因此，要使用 varargs 创建方法，必须显式设置方法修饰符。假设要定义下面这个方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">(<span class="keyword">int</span>... args)</span> </span>&#123; <span class="keyword">return</span> args.length; &#125;</div></pre></td></tr></table></figure>
<p>使用 Javassist 应该是这样的：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CtClass <span class="keyword">cc</span> = <span class="comment">/* target class */</span>;</div><div class="line">CtMethod <span class="keyword">m</span> = CtMethod.make(<span class="string">"public int length(int[] args) &#123; return args.length; &#125;"</span>, <span class="keyword">cc</span>);</div><div class="line"><span class="keyword">m</span>.setModifiers(<span class="keyword">m</span>.getModifiers() | Modifier.VARARGS);</div><div class="line"><span class="keyword">cc</span>.addMethod(<span class="keyword">m</span>);</div></pre></td></tr></table></figure></p>
<p>参数类型<code>int ...</code>被更改为<code>int []</code>，<code>Modifier.VARARGS</code>被添加到方法修饰符中。</p>
<p>要在由 Javassist 的编译器编译的源代码中调用此方法，需要这样写：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">length(new int[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);</div></pre></td></tr></table></figure></p>
<p>而不是这样：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">length(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div></pre></td></tr></table></figure></p>
<h2 id="8-J2ME"><a href="#8-J2ME" class="headerlink" title="8. J2ME"></a>8. J2ME</h2><p>如果要修改 J2ME 执行环境的类文件，则必须先执行预验证。预验证基本上是生成堆栈映射，这类似于在 JDK 1.6 中引入 J2SE 的堆栈映射表。当<code>javassist.bytecode.MethodInfo.doPreverify</code> 为 true 时，Javassist 才会维护 J2ME 的堆栈映射。</p>
<p>对于指定的 CtMethod 对象，你可以调用以下方法，手动生成堆栈映射：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m<span class="selector-class">.getMethodInfo</span>()<span class="selector-class">.rebuildStackMapForME</span>(cpool);</div></pre></td></tr></table></figure></p>
<p>这里，cpool 是一个 ClassPool 对象，通过在 CtClass 对象上调用 getClassPool() 可以获得。 ClassPool 对象负责从给定类路径中查找类文件。要获得所有的 CtMethod 对象，需要在 CtClass 对象上调用 getDeclaredMethods() 方法。</p>
<h2 id="9-装箱-拆箱"><a href="#9-装箱-拆箱" class="headerlink" title="9.装箱/拆箱"></a>9.装箱/拆箱</h2><p>Java 中的装箱和拆箱是语法糖。没有用于装箱或拆箱的字节码。所以 Javassist 的编译器不支持它们。 例如，以下语句在 Java 中有效：</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">Integer i </span>=<span class="string"> 3;</span></div></pre></td></tr></table></figure>
<p>因为隐式地执行了装箱。 但是，对于 Javassist，必须将值类型从 int 显式地转换为 Integer：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Integer</span> i = <span class="literal">new</span> <span class="built_in">Integer</span>(<span class="number">3</span>);</div></pre></td></tr></table></figure></p>
<h2 id="10-调试"><a href="#10-调试" class="headerlink" title="10. 调试"></a>10. 调试</h2><p>将 CtClass.debugDump 设为本地目录。 然后 Javassist 修改和生成的所有类文件都保存在该目录中。要停止此操作，将 CtClass.debugDump 设置为 null 即可。其默认值为 null。</p>
<p>例如，<br><figure class="highlight fix"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">CtClass.debugDump </span>=<span class="string">“./dump”;</span></div></pre></td></tr></table></figure></p>
<p>所有修改的类文件都保存在 ./dump 中。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://erhu.party/2016/11/23/javassist-tutorial-3/" data-id="ciw196ry50009j8qaeew57tc0" class="article-share-link">分享到</a><div class="tags"><a href="/tags/javassist/">javassist</a></div><div class="post-nav"><a href="/2016/11/28/2016年11月/" class="pre">2016年11月</a><a href="/2016/11/23/javassist-turorial-2/" class="next">Javassist 使用指南（二）</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/camera/" style="font-size: 15px;">camera</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/besier/" style="font-size: 15px;">besier</a> <a href="/tags/技术分享/" style="font-size: 15px;">技术分享</a> <a href="/tags/photography/" style="font-size: 15px;">photography</a> <a href="/tags/javassist/" style="font-size: 15px;">javassist</a> <a href="/tags/培训/" style="font-size: 15px;">培训</a> <a href="/tags/emacs/" style="font-size: 15px;">emacs</a> <a href="/tags/scinece/" style="font-size: 15px;">scinece</a> <a href="/tags/月结/" style="font-size: 15px;">月结</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/11/28/2016年11月/">2016年11月</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/23/javassist-tutorial-3/">Javassist 使用指南（三）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/23/javassist-turorial-2/">Javassist 使用指南（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/17/javassist-turorial-1/">Javassist 使用指南（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/10/training-of-training/">培训的培训</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/01/fantastic-ppt/">技术分享圆满成功</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/18/photograph001/">摄影作品001</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/16/besier/">贝塞尔曲线</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/29/get-system-service/">追踪 getSystemService(...)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/29/window-manager/">从源码角度解析悬浮窗</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">四十岁退休.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>