<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Javassist 使用指南（一） | 四十岁退休</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Javassist 使用指南（一）</h1><a id="logo" href="/.">四十岁退休</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Javassist 使用指南（一）</h1><div class="post-meta">Nov 17, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p><strong>本文译自：</strong> <a href="https://github.com/jboss-javassist/javassist/wiki/Tutorial-1" target="_blank" rel="external">Javassist Tutorial-1</a><br><strong>完成时间：</strong>2016年11月</p>
<h2 id="1-读写字节码"><a href="#1-读写字节码" class="headerlink" title="1. 读写字节码"></a>1. 读写字节码</h2><p>我们知道 Java 字节码以二进制的形式存储在 class 文件中，每一个 class 文件包含一个 Java 类或接口。Javaassist 就是一个用来处理 Java 字节码的类库。</p>
<p>在 Javassist 中，类 <code>Javaassit.CtClass</code> 表示 class 文件。一个 GtClass (编译时类）对象可以处理一个 class 文件，下面是一个简单的例子：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ClassPool pool = ClassPool.getDefault();</div><div class="line">CtClass <span class="keyword">cc</span> = pool.<span class="built_in">get</span>(<span class="string">"test.Rectangle"</span>);</div><div class="line"><span class="keyword">cc</span>.setSuperclass(pool.<span class="built_in">get</span>(<span class="string">"test.Point"</span>));</div><div class="line"><span class="keyword">cc</span>.writeFile();</div></pre></td></tr></table></figure>
<p>这段代码首先获取一个 ClassPool 对象。ClassPool 是 CtClass 对象的容器。它按需读取类文件来构造 CtClass 对象，并且保存 CtClass 对象以便以后使用。</p>
<p>为了修改类的定义，首先需要使用 ClassPool.get() 方法来从 ClassPool 中获得一个 CtClass 对象。上面的代码中，我们从 ClassPool 中获得了代表 test.Rectangle 类的 CtClass 对象的引用，并将其赋值给变量 cc。使用 getDefault() 方法获取的 ClassPool 对象使用的是默认系统的类搜索路径。</p>
<p>从实现的角度来看，ClassPool 是一个存储 CtClass 的 Hash 表，类的名称作为 Hash 表的 key。ClassPool 的 get() 函数用于从 Hash 表中查找 key 对应的 CtClass 对象。如果没有找到，get() 函数会创建并返回一个新的 CtClass 对象，这个新对象会保存在 Hash 表中。</p>
<p>从 ClassPool 中获取的 CtClass 是可以被修改的（稍后会讨论细节）。</p>
<p>在上面的例子中，test.Rectangle 的父类被设置为 test.Point。调用 writeFile() 后，这项修改会被写入原始类文件。writeFile() 会将 CtClass 对象转换成类文件并写到本地磁盘。也可以使用 toBytecode() 函数来获取修改过的字节码：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">byte[] </span><span class="keyword">b </span>= cc.toBytecode()<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>你也可以通过 toClass() 函数直接将 CtClass 转换成 Class 对象:</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">Class</span> <span class="title">clazz</span> = <span class="title">cc</span>.<span class="title">toClass</span>();</span></div></pre></td></tr></table></figure>
<p>toClass() 请求当前线程的 ClassLoader 加载 CtClass 所代表的类文件。它返回此类文件的 java.lang.Class 对象，更多细节，请参考<a href="https://github.com/jboss-javassist/javassist/wiki/Tutorial-1#toclass" target="_blank" rel="external">下面的章节</a>。</p>
<h4 id="定义新类"><a href="#定义新类" class="headerlink" title="定义新类"></a>定义新类</h4><p>使用 ClassPool 的 makeClass() 方法可以定义一个新类。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ClassPool pool = ClassPool.getDefault()<span class="comment">;</span></div><div class="line">CtClass cc = pool.makeClass(<span class="string">"Point"</span>)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>这段代码定义了一个空的 Point 类。Point 类的成员方法可以通过 CtNewMethod 类的工厂方法来创建，然后使用 CtClass 的 addMethod() 方法将其添加到 Point 中。</p>
<p>使用 ClassPool 中的 makeInterface() 方法可以创建新接口。接口中的方法可以使用 CtNewMethod 的 abstractMethod() 方法创建。</p>
<h4 id="将类冻结"><a href="#将类冻结" class="headerlink" title="将类冻结"></a>将类冻结</h4><p>如果一个 CtClass 对象通过 writeFile(), toClass(), toBytecode() 被转换成一个类文件，此 CtClass 对象会被冻结起来，不允许再修改。因为一个类只能被 JVM 加载一次。</p>
<p>但是，一个冷冻的 CtClass 也可以被解冻，例如：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CtClasss <span class="keyword">cc</span> = ...;</div><div class="line">    :</div><div class="line"><span class="keyword">cc</span>.writeFile();</div><div class="line"><span class="keyword">cc</span>.defrost();</div><div class="line"><span class="keyword">cc</span>.setSuperclass(...);    <span class="comment">// 因为类已经被解冻，所以这里可以调用成功</span></div></pre></td></tr></table></figure>
<p>调用 defrost() 之后，此 CtClass 对象又可以被修改了。</p>
<p>如果 ClassPool.doPruning 被设置为 true，Javassist 在冻结 CtClass 时，会修剪 CtClass 的数据结构。为了减少内存的消耗，修剪操作会丢弃 CtClass 对象中不必要的属性。例如，Code_attribute 结构会被丢弃。一个 CtClass 对象被修改之后，方法的字节码是不可访问的，但是方法名称、方法签名、注解信息可以被访问。修剪过的 CtClass 对象不能再次被解冻。ClassPool.doPruning 的默认值为 false。</p>
<p>stopPruning() 可以用来驳回修剪操作。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CtClasss cc = ...;</div><div class="line">cc.stopPruning(<span class="literal">true</span>);</div><div class="line">    :</div><div class="line">cc.writeFile(); <span class="regexp">//</span> 转换成一个 <span class="class"><span class="keyword">class</span> 文件</span></div><div class="line"><span class="regexp">//</span> cc <span class="keyword">is</span> <span class="keyword">not</span> pruned.</div></pre></td></tr></table></figure>
<p>这个 CtClass 没有被修剪，所以在 writeFile() 之后，可以被解冻。</p>
<p><strong>注意</strong>：调试的时候，你可能临时需要停止修剪和冻结，然后保存一个修改过的类文件到磁盘，debugWriteFile() 方法正是为此准备的。它停止修剪，然后写类文件，然后解冻并再次打开修剪（如果开始时修养是打开的）。</p>
<h4 id="类搜索路径"><a href="#类搜索路径" class="headerlink" title="类搜索路径"></a>类搜索路径</h4><p>通过 ClassPool.getDefault() 获取的 ClassPool 使用 JVM 的类搜索路径。如果程序运行在 JBoss 或者 Tomcat 等 Web 服务器上，ClassPool 可能无法找到用户的类，因为 Web 服务器使用多个类加载器作为系统类加载器。在这种情况下，ClassPool 必须添加额外的类搜索路径。</p>
<p>下面的例子中，pool 代表一个 ClassPool 对象：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pool.insertClassPath(<span class="keyword">new</span> ClassClassPath(<span class="keyword">this</span>.getClass()));</div></pre></td></tr></table></figure>
<p>上面的语句将 this 指向的类添加到 pool 的类加载路径中。你可以使用任意 Class 对象来代替 this.getClass()，从而将 Class 对象添加到类加载路径中。</p>
<p>也可以注册一个目录作为类搜索路径。下面的例子将 /usr/local/javalib 添加到类搜索路径中：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ClassPool <span class="attr">pool</span> = ClassPool.getDefault();</div><div class="line">pool.insertClassPath(<span class="string">"/usr/local/javalib"</span>);</div></pre></td></tr></table></figure>
<p>类搜索路径不但可以是目录，还可以是 URL ：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">ClassPool</span> pool = ClassPool.getDefault()<span class="comment">;</span></div><div class="line"><span class="symbol">ClassPath</span> <span class="meta">cp</span> = new URLClassPath(<span class="string">"www.javassist.org"</span>, <span class="number">80</span>, <span class="string">"/java/"</span>, <span class="string">"org.javassist."</span>)<span class="comment">;</span></div><div class="line"><span class="symbol">pool.insertClassPath</span>(<span class="meta">cp</span>)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>上述代码将 <a href="http://www.javassist.org:80/java/" target="_blank" rel="external">http://www.javassist.org:80/java/</a> 添加到类搜索路径。并且这个URL只能搜索 <code>org.javassist</code> 包里面的类。例如，为了加载 <code>org.javassist.test.Main</code>，它的类文件会从获取 <a href="http://www.javassist.org:80/java/org/javassist/test/Main.class" target="_blank" rel="external">http://www.javassist.org:80/java/org/javassist/test/Main.class</a> 获取。</p>
<p>此外，也可以直接传递一个 byte 数组给 ClassPool 来构造一个 CtClass 对象，完成这项操作，需要使用 ByteArrayPath 类。示例：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ClassPool cp = ClassPool.getDefault()<span class="comment">;</span></div><div class="line"><span class="keyword">byte[] </span><span class="keyword">b </span>= a <span class="keyword">byte </span>array<span class="comment">;</span></div><div class="line">String name = class name<span class="comment">;</span></div><div class="line">cp.<span class="keyword">insertClassPath(new </span><span class="keyword">ByteArrayClassPath(name, </span><span class="keyword">b));</span></div><div class="line">CtClass cc = cp.get(name)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>示例中的 CtClass 对象表示 b 代表的 class 文件。将对应的类名传递给 ClassPool 的 get() 方法，就可以从 ByteArrayClassPath 中读取到对应的类文件。</p>
<p>如果你不知道类的全名，可以使用 makeClass() 方法：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ClassPool cp = ClassPool.getDefault();</div><div class="line">InputStream <span class="keyword">ins</span> = <span class="keyword">an</span> <span class="keyword">input</span> stream <span class="keyword">for</span> reading a <span class="keyword">class</span> <span class="keyword">file</span>;</div><div class="line">CtClass <span class="keyword">cc</span> = cp.makeClass(<span class="keyword">ins</span>);</div></pre></td></tr></table></figure>
<p>makeClass() 返回从给定输入流构造的 CtClass 对象。 你可以使用 makeClass() 将类文件提供给 ClassPool 对象。如果搜索路径包含大的 jar 文件，这可能会提高性能。由于 ClassPool 对象按需读取类文件，它可能会重复搜索整个 jar 文件中的每个类文件。 makeClass() 可以用于优化此搜索。由 makeClass() 构造的 CtClass 保存在 ClassPool 对象中，从而使得类文件不会再被读取。</p>
<p>用户可以通过实现 ClassPath 接口来扩展类加载路径，然后调用 ClassPool 的 insertClassPath() 方法将路径添加进来。这种技术主要用于将非标准资源添加到类搜索路径中。</p>
<h2 id="2-ClassPool"><a href="#2-ClassPool" class="headerlink" title="2. ClassPool"></a>2. ClassPool</h2><p>ClassPool 是 CtClass 对象的容器。因为编译器在编译引用 CtClass 代表的 Java 类的源代码时，可能会引用 CtClass 对象，所以一旦一个 CtClass 被创建，它就被保存在 ClassPool 中.</p>
<p>例如，一个 CtClass 类代表 Point 类，并给 CtClass 添加 getter() 方法。然后，程序尝试编译一段代码，代码中包含了 Point 的 getter() 调用，然后将这段代码添加了另一个类 Line 中，如果代表 Point 的 CtClass 丢失，编译器就无法编译 Line 中的 Point.getter() 方法。注：原来的 Point 类中无 getter() 方法。因此，为了能够正确编译这个方法调用，ClassPool 必须在程序执行期间包含所有的 CtClass 实例。</p>
<h4 id="避免内存溢出"><a href="#避免内存溢出" class="headerlink" title="避免内存溢出"></a>避免内存溢出</h4><p>如果 CtClass 对象的数量变得非常大（这种情况很少发生，因为 Javassist 试图以各种方式减少内存消耗），ClassPool 可能会导致巨大的内存消耗。 为了避免此问题，可以从 ClassPool 中显式删除不必要的 CtClass 对象。 如果对 CtClass 对象调用 detach()，那么该 CtClass 对象将被从 ClassPool 中删除。 例如：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CtClass cc = ... <span class="comment">;</span></div><div class="line">cc.writeFile()<span class="comment">;</span></div><div class="line">cc.detach()<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>在调用 detach() 之后，就不能调用这个 CtClass 对象的任何方法了。但是如果你调用 ClassPool 的 get() 方法，ClassPool 会再次读取这个类文件，创建一个新的 CtClass 对象。</p>
<p>另一个办法是用新的 ClassPool 替换旧的 ClassPool，并将旧的 ClassPool 丢弃。 如果旧的 ClassPool 被垃圾回收掉，那么包含在 ClassPool 中的 CtClass 对象也会被回收。要创建一个新的 ClassPool，参见以下代码：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ClassPool cp = <span class="keyword">new</span> ClassPool(<span class="literal">true</span>);</div><div class="line"><span class="comment">// if needed, append an extra search path by appendClassPath()</span></div></pre></td></tr></table></figure>
<p>这段代码创建了一个 ClassPool 对象，它的行为与 ClassPool.getDefault() 类似。 请注意，ClassPool.getDefault() 是为了方便而提供的单例工厂方法，它保留了一个<code>ClassPool</code>的单例并重用它。getDefault() 返回的 ClassPool 对象并没有特殊之处。</p>
<p><strong>注意</strong>：new ClassPool(true) 构造一个 ClassPool 对象，并附加了系统搜索路径。<br>调用此构造函数等效于以下代码：</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="type">ClassPool</span> cp = <span class="function"><span class="keyword">new</span> <span class="title">ClassPool</span>();</span></div><div class="line"><span class="title">cp</span>.<span class="title">appendSystemPath</span>();  <span class="comment">// or append another path by appendClassPath()</span></div></pre></td></tr></table></figure>
<h4 id="级联的-ClassPools"><a href="#级联的-ClassPools" class="headerlink" title="级联的 ClassPools"></a>级联的 ClassPools</h4><p>如果程序正在 Web 应用程序服务器上运行，则可能需要创建多个 ClassPool 实例; 应为每一个 ClassLoader 创建一个 ClassPool 的实例。 程序应该通过 ClassPool 的构造函数，而不是调用 getDefault() 来创建一个 ClassPool 对象。<br>多个 ClassPool 对象可以像 java.lang.ClassLoader 一样级联。 例如，</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ClassPool <span class="keyword">parent</span> = ClassPool.getDefault();</div><div class="line">ClassPool child = <span class="literal">new</span> ClassPool(<span class="keyword">parent</span>);</div><div class="line">child.insertClassPath(<span class="string">"./classes"</span>);</div></pre></td></tr></table></figure>
<p>如果调用 child.get()，子 ClassPool 首先委托给父 ClassPool。如果父 ClassPool 找不到类文件，那么子 ClassPool 会尝试在 ./classes 目录下查找类文件。</p>
<p>如果 child.childFirstLookup 返回 true，那么子类 ClassPool 会在委托给父 ClassPool 之前尝试查找类文件。 例如：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ClassPool <span class="keyword">parent</span> = ClassPool.getDefault();</div><div class="line">ClassPool child = <span class="literal">new</span> ClassPool(<span class="keyword">parent</span>);</div><div class="line">child.appendSystemPath();         <span class="comment">// the same class path as the default one.</span></div><div class="line">child.childFirstLookup = <span class="literal">true</span>;    <span class="comment">// changes the behavior of the child.</span></div></pre></td></tr></table></figure>
<h4 id="拷贝一个已经存在的类来定义一个新的类"><a href="#拷贝一个已经存在的类来定义一个新的类" class="headerlink" title="拷贝一个已经存在的类来定义一个新的类"></a>拷贝一个已经存在的类来定义一个新的类</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ClassPool pool = ClassPool.getDefault()<span class="comment">;</span></div><div class="line">CtClass cc = pool.get(<span class="string">"Point"</span>)<span class="comment">;</span></div><div class="line">cc.setName(<span class="string">"Pair"</span>)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>这个程序首先获得类 Point 的 CtClass 对象。然后它调用 setName() 将这个 CtClass 对象的名称设置为 Pair。在这个调用之后，这个 CtClass 对象所代表的类的名称 Point 被修改为 Pair。类定义的其他部分不会改变。</p>
<p><strong>注意</strong>：CtClass 中的 setName() 改变了 ClassPool 中的记录。从实现的角度来看，一个 ClassPool 对象是一个 CtClass 对象的哈希表。setName() 更改了与哈希表中的 CtClass 对象相关联的 Key。Key 从原始类名更改为新类名。</p>
<p>因此，如果后续在 ClassPool 对象上再次调用 get(“Point”)，则它不会返回变量 cc 所指的 CtClass 对象。 而是再次读取类文件 Point.class，并为类 Point 构造一个新的 CtClass 对象。 因为与 Point 相关联的 CtClass 对象不再存在。示例：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ClassPool pool = ClassPool.getDefault();</div><div class="line">CtClass <span class="keyword">cc</span> = pool.<span class="built_in">get</span>(<span class="string">"Point"</span>);</div><div class="line">CtClass cc1 = pool.<span class="built_in">get</span>(<span class="string">"Point"</span>);   <span class="comment">// cc1 is identical to cc.</span></div><div class="line"><span class="keyword">cc</span>.setName(<span class="string">"Pair"</span>);</div><div class="line">CtClass cc2 = pool.<span class="built_in">get</span>(<span class="string">"Pair"</span>);    <span class="comment">// cc2 is identical to cc.</span></div><div class="line">CtClass cc3 = pool.<span class="built_in">get</span>(<span class="string">"Point"</span>);   <span class="comment">// cc3 is not identical to cc.</span></div></pre></td></tr></table></figure>
<p>cc1 和 cc2 指向 CtClass 的同一个实例，而 cc3 不是。 注意，在执行 cc.setName(“Pair”) 之后，cc 和 cc1 引用的 CtClass 对象都表示 Pair 类。</p>
<p>ClassPool 对象用于维护类和 CtClass 对象之间的一对一映射关系。 为了保证程序的一致性，Javassist 不允许用两个不同的 CtClass 对象来表示同一个类，除非创建了两个独立的 ClassPool。</p>
<p>如果你有两个 ClassPool 对象，那么你可以从每个 ClassPool 中，获取一个表示相同类文件的不同的 CtClass 对象。 你可以修改这些 CtClass 对象来生成不同版本的类。</p>
<h4 id="通过重命名冻结的类来生成新的类"><a href="#通过重命名冻结的类来生成新的类" class="headerlink" title="通过重命名冻结的类来生成新的类"></a>通过重命名冻结的类来生成新的类</h4><p>一旦一个 CtClass 对象被 writeFile() 或 toBytecode() 转换为一个类文件，Javassist 会拒绝对该 CtClass 对象的进一步修改。因此，在表示 Point 类的 CtClass 对象被转换为类文件之后，你不能将 Pair 类定义为 Point 的副本，因为在 Point 上执行 setName() 会被拒绝。 以下代码段是错误的：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ClassPool pool = ClassPool.getDefault();</div><div class="line">CtClass <span class="keyword">cc</span> = pool.<span class="built_in">get</span>(<span class="string">"Point"</span>);</div><div class="line"><span class="keyword">cc</span>.writeFile();</div><div class="line"><span class="keyword">cc</span>.setName(<span class="string">"Pair"</span>);    <span class="comment">// wrong since writeFile() has been called.</span></div></pre></td></tr></table></figure>
<p>为了避免这种限制，你应该在 ClassPool 中调用 getAndRename() 方法。 例如：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ClassPool pool = ClassPool.getDefault()<span class="comment">;</span></div><div class="line">CtClass cc = pool.get(<span class="string">"Point"</span>)<span class="comment">;</span></div><div class="line">cc.writeFile()<span class="comment">;</span></div><div class="line">CtClass cc2 = pool.getAndRename(<span class="string">"Point"</span>, <span class="string">"Pair"</span>)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>如果调用 getAndRename()，ClassPool 首先读取 Point.class 来创建一个新的表示 Point 类的 CtClass 对象。 而且，它会在这个 CtClass 被记录到哈希表之前，将 CtClass 对象重命名为 Pair。因此，getAndRename() 可以在表示 Point 类的 CtClass 对象上调用 writeFile() 或 toBytecode() 后执行。</p>
<h2 id="3-类加载器-Class-Loader"><a href="#3-类加载器-Class-Loader" class="headerlink" title="3. 类加载器 (Class Loader)"></a>3. 类加载器 (Class Loader)</h2><p>如果事先知道要修改哪些类，修改类的最简单方法如下：</p>
<ol>
<li>调用 ClassPool.get() 获取 CtClass 对象，</li>
<li>修改 CtClass</li>
<li>调用 CtClass 对象的 writeFile() 或者 toBytecode() 获得修改过的类文件。</li>
</ol>
<p>如果在加载时，可以确定是否要修改某个类，用户必须使 Javassist 与类加载器协作，以便在加载时修改字节码。用户可以定义自己的类加载器，也可以使用 Javassist 提供的类加载器。</p>
<h3 id="3-1-CtClass-toClass"><a href="#3-1-CtClass-toClass" class="headerlink" title="3.1 CtClass.toClass()"></a>3.1 CtClass.toClass()</h3><p>CtClass 的 toClass() 方法请求当前线程的上下文类加载器，加载 CtClass 对象所表示的类。要调用此方法，调用者必须具有相关的权限; 否则，可能会抛出 SecurityException。示例：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hello</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Hello"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws Exception </span>&#123;</div><div class="line">        ClassPool cp = ClassPool.getDefault();</div><div class="line">        CtClass cc = cp.<span class="keyword">get</span>(<span class="string">"Hello"</span>);</div><div class="line">        CtMethod m = cc.getDeclaredMethod(<span class="string">"say"</span>);</div><div class="line">        m.insertBefore(<span class="string">"&#123; System.out.println(\"Hello.say():\"); &#125;"</span>);</div><div class="line">        Class c = cc.toClass();</div><div class="line">        Hello h = (Hello)c.newInstance();</div><div class="line">        h.say();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Test.main() 在 Hello 中的 say() 方法体中插入一个 println()。然后它构造一个修改过的 Hello 类的实例，并在该实例上调用 say() 。<br><strong>注意</strong>：上面的程序要正常运行，Hello 类在调用 toClass() 之前不能被加载。 如果 JVM 在 toClass() 调用之前加载了原始的 Hello 类，后续加载修改的 Hello 类将会失败（LinkageError 抛出）。<br>例如，如果 Test 中的 main() 是这样的：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;</div><div class="line">    Hello orig = <span class="keyword">new</span> Hello();</div><div class="line">    ClassPool cp = ClassPool.getDefault();</div><div class="line">    CtClass cc = cp.<span class="built_in">get</span>(<span class="string">"Hello"</span>);</div><div class="line">        :</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么，原始的 Hello 类在 main 的第一行被加载，toClass() 调用会抛出一个异常，因为类加载器不能同时加载两个不同版本的 Hello 类。</p>
<p>如果程序在某些应用程序服务器（如JBoss和Tomcat）上运行，toClass() 使用的上下文类加载器可能是不合适的。在这种情况下，你会看到一个意想不到的 ClassCastException。为了避免这个异常，必须给 toClass() 指定一个合适的类加载器。 例如，如果 ‘bean’ 是你的会话 bean 对象，那么下面的代码：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CtClass <span class="keyword">cc</span> = ...;</div><div class="line"><span class="keyword">Class</span> c = <span class="keyword">cc</span>.toClass(bean.getClass().getClassLoader());</div></pre></td></tr></table></figure>
<p>可以工作。你应该给 toClass() 传递加载了你的程序的类加载器（上例中，<code>bean</code>对象的类）。</p>
<p>toClass() 是为了简便而提供的方法。如果你需要更复杂的功能，你应该编写自己的类加载器。</p>
<h3 id="3-2-Java的类加载机制"><a href="#3-2-Java的类加载机制" class="headerlink" title="3.2 Java的类加载机制"></a>3.2 Java的类加载机制</h3><p>在Java中，多个类加载器可以共存，每个类加载器创建自己的名称空间。不同的类加载器可以加载具有相同类名的不同类文件。加载的两个类被视为不同的类。此功能使我们能够在单个 JVM 上运行多个应用程序，即使这些程序包含具有相同名称的不同的类。</p>
<p><strong>注意</strong>：JVM 不允许动态重新加载类。一旦类加载器加载了一个类，它不能在运行时重新加载该类的修改版本。因此，在JVM 加载类之后，你不能更改类的定义。但是，JPDA（Java平台调试器架构）提供有限的重新加载类的能力。参见<a href="#hotswap">3.6节</a>。</p>
<p>如果相同的类文件由两个不同的类加载器加载，则 JVM 会创建两个具有相同名称和定义的不同的类。由于两个类不相同，一个类的实例不能被分配给另一个类的变量。两个类之间的转换操作将失败并抛出一个 ClassCastException。<br>例如，下面的代码会抛出异常：</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="type">MyClassLoader</span> myLoader = <span class="function"><span class="keyword">new</span> <span class="title">MyClassLoader</span>();</span></div><div class="line"><span class="title">Class</span> <span class="title">clazz</span> = <span class="title">myLoader</span>.<span class="title">loadClass</span>("<span class="type">Box</span>");</div><div class="line"><span class="title">Object</span> <span class="title">obj</span> = <span class="title">clazz</span>.<span class="title">newInstance</span>();</div><div class="line"><span class="title">Box</span> <span class="title">b</span> = (<span class="type">Box</span>)<span class="title">obj</span>;    <span class="comment">// this always throws ClassCastException.</span></div></pre></td></tr></table></figure>
<p>Box 类由两个类加载器加载。假设类加载器 CL 加载包含此代码片段的类。因为这段代码引用了 MyClassLoader，Class，Object 和 Box，CL 也加载这些类（除非它委托给另一个类加载器）。 因此，变量 b 的类型是 CL 加载的 Box 类。 另一方面， myLoader 也加载了 Box class。 对象 obj 是由 myLoader 加载的 Box 类的一个实例。 因此，最后一个语句总是抛出 ClassCastException ，因为 obj 的类是一个不同的 Box 类的类型，而不是用作变量 b 的类型。</p>
<p>多个类加载器形成一个树型结构。 除引导类加载器之外的每个类加载器，都有一个父类加载器，它通常加载该子类加载器的类。 因为加载类的请求可以沿类加载器的这个层次委派，所以即使你没有请求加载一个类，它也可能被加载。因此，已经请求加载类 C 的类加载器可以不同于实际加载类 C 的加载器。为了区分，我们将前加载器称为 C 的发起者，将后加载器称为 C 的实际加载器 。</p>
<p>此外，如果请求加载类 C（C的发起者）的类加载器 CL 委托给父类加载器 PL，则类加载器 CL 不会加载类 C 引用的任何类。因为 CL 不是那些类的发起者。 相反，父类加载器 PL 成为它们的启动器，并且加载它们。</p>
<p>请参考下面的例子来理解：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Point</span> &#123;    <span class="comment">// loaded by PL</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x, y;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> x; &#125;</div><div class="line">        :</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Box</span> &#123;      <span class="comment">// the initiator is L but the real loader is PL</span></div><div class="line">    <span class="keyword">private</span> Point upperLeft, size;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBaseX</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> upperLeft.x; &#125;</div><div class="line">        :</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Window</span> &#123;    <span class="comment">// loaded by a class loader L</span></div><div class="line">    <span class="keyword">private</span> Box box;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBaseX</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> box.getBaseX(); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设一个类 Window 由类加载器 L 加载。Window 的启动器和实际加载器都是 L。由于 Window 的定义引用了 Box，JVM 将请求 L 加载 Box。 这里，假设 L 将该任务委托给父类加载器 PL。Box 的启动器是 L，但真正的加载器是 PL。 在这种情况下，Point 的启动器不是 L 而是 PL，因为它与 Box 的实际加载器相同。 因此，Point 不会被 L 加载。</p>
<p>接下来，看一个稍微修改过的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x, y;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</div><div class="line">        :</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;      <span class="comment">// the initiator is L but the real loader is PL</span></div><div class="line">    <span class="keyword">private</span> Point upperLeft, size;</div><div class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size; &#125;</div><div class="line">        :</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;    <span class="comment">// loaded by a class loader L</span></div><div class="line">    <span class="keyword">private</span> Box box;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">widthIs</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</div><div class="line">        Point p = box.getSize();</div><div class="line">        <span class="keyword">return</span> w == p.getX();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，Window 的定义也引用了 Point。 在这种情况下，如果请求加载 Point，类加载器 L 也必须委托给 PL。 <strong>你必须避免有两个类加载器两次加载同一个类</strong>。两个加载器之一必须委托给另一个。</p>
<p>当 Point 加载时，如果 L 不委托给 PL，widthIs() 就会抛出一个 ClassCastException 异常。因为 Box 的实际加载器是 PL，在 Box 中引用的 Point 也由 PL 加载。 getSize() 的结果值是由 PL 加载的 Point，widthIs() 中的变量 p 是由 L 加载的 Point。JVM 认为它们是不同的类型，因此它会抛出类型不匹配的异常。</p>
<p>这种设计有点不方便，但也是必须的。</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">Point p </span>=<span class="string"> box.getSize();</span></div></pre></td></tr></table></figure>
<p>如果上面的语句没有抛出异常，那么 Window 的程序员可以破坏 Point 对象的封装。 例如，字段 x 在 PL 中加载的 Point 中是私有的。 然而，如果 L 加载具有以下定义的 Point，则 Window 类可以直接访问 x 的值：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Point</span> &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x, y;    <span class="comment">// not private</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> x; &#125;</div><div class="line">        :</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有关 Java 类加载器的更多详细信息，可以参看以下文章：</p>
<blockquote>
<p>Sheng Liang 和 Gilad Bracha，“Dynamic Class Loading in the Java Virtual Machine”，<em> ACM OOPSLA’98 </em>，pp.36-44,1998。</p>
</blockquote>
<h3 id="3-3-使用-javassist-Loader"><a href="#3-3-使用-javassist-Loader" class="headerlink" title="3.3 使用 javassist.Loader"></a>3.3 使用 javassist.Loader</h3><p>Javassit 提供一个类加载器 javassist.Loader。它使用 javassist.ClassPool 对象来读取类文件。<br>例如，javassist.Loader 可以用于加载用 Javassist 修改过的类。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> javassist.*;</div><div class="line"><span class="keyword">import</span> test.Rectangle;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="type">String</span>[] args) <span class="keyword">throws</span> <span class="type">Throwable</span> &#123;</div><div class="line">     <span class="type">ClassPool</span> pool = <span class="type">ClassPool</span>.getDefault();</div><div class="line">     <span class="type">Loader</span> cl = new <span class="type">Loader</span>(pool);</div><div class="line"></div><div class="line">     <span class="type">CtClass</span> ct = pool.<span class="keyword">get</span>(<span class="string">"test.Rectangle"</span>);</div><div class="line">     ct.setSuperclass(pool.<span class="keyword">get</span>(<span class="string">"test.Point"</span>));</div><div class="line"></div><div class="line">     <span class="type">Class</span> <span class="built_in">c</span> = cl.loadClass(<span class="string">"test.Rectangle"</span>);</div><div class="line">     <span class="type">Object</span> rect = <span class="built_in">c</span>.newInstance();</div><div class="line">         :</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个程序将 test.Rectangle 的超类设置为 test.Point。然后再加载修改的类，并创建新的 test.Rectangle 类的实例。</p>
<p>如果用户希望在加载时按需修改类，则可以向 javassist.Loader 添加事件监听器。当类加载器加载类时会通知监听器。事件监听器类必须实现以下接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Translator</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(ClassPool pool)</span></span></div><div class="line">        <span class="keyword">throws</span> NotFoundException, CannotCompileException;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoad</span><span class="params">(ClassPool pool, String classname)</span></span></div><div class="line">        <span class="keyword">throws</span> NotFoundException, CannotCompileException;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当事件监听器通过 addTranslator() 添加到 javassist.Loader 对象时，start() 方法会被调用。在 javassist.Loader 加载类之前，会调用 onLoad() 方法。可以在 onLoad() 方法中修改被加载的类的定义。</p>
<p>例如，下面的事件监听器在类加载之前，将所有类更改为 public 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTranslator</span> <span class="keyword">implements</span> <span class="title">Translator</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(ClassPool pool)</span> <span class="keyword">throws</span> NotFoundException, CannotCompileException </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLoad</span><span class="params">(ClassPool pool, String classname)</span> <span class="keyword">throws</span> NotFoundException, CannotCompileException </span>&#123;</div><div class="line">        CtClass cc = pool.get(classname);</div><div class="line">        cc.setModifiers(Modifier.PUBLIC);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，onLoad() 不必调用 toBytecode() 或 writeFile()，因为 javassist.Loader 会调用这些方法来获取类文件。</p>
<p>要使用 MyTranslator 对象运行一个应用程序类 MyApp，主类代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> javassist.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">     Translator t = <span class="keyword">new</span> MyTranslator();</div><div class="line">     ClassPool pool = ClassPool.getDefault();</div><div class="line">     Loader cl = <span class="keyword">new</span> Loader();</div><div class="line">     cl.addTranslator(pool, t);</div><div class="line">     cl.run(<span class="string">"MyApp"</span>, args);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行下面的命令来运行程序：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">%</span> java Mai<span class="symbol">n2</span> ar<span class="name">g1</span> ar<span class="name">g2.</span>..</div></pre></td></tr></table></figure>
<p>类 MyApp 和其他应用程序类会被 MyTranslator 监听。</p>
<p>注意，MyApp 不能访问 loader 类，如 Main2，MyTranslator 和 ClassPool，因为它们是由不同的加载器加载的。 应用程序类由 javassist.Loader 加载，而加载器类（例如 Main2）由默认的 Java 类加载器加载。</p>
<p>javassist.Loader 以不同的顺序从 java.lang.ClassLoader 中搜索类。ClassLoader 首先将加载操作委托给父类加载器，只有当父类加载器无法找到它们时才尝试自己加载类。另一方面，javassist.Loader 尝试在委托给父类加载器之前加载类。它仅在以下情况下进行委派：</p>
<ol>
<li>在 ClassPool 对象上调用 get() 找不到这个类；</li>
<li>这些类已经通过 delegateLoadingOf() 来指定由父类加载器加载。</li>
</ol>
<p>此搜索顺序允许 Javassist 加载修改过的类。但是，如果找不到修改的类，它将委托父类加载器来加载。一旦一个类被父类加载器加载，那个类中引用的其他类也将被父类加载器加载，因此它们是没有被修改的。 回想一下，C 类引用的所有类都由 C 的实际加载器加载的。如果你的程序无法加载修改的类，你应该确保所有使用该类的类都是由 javassist 加载的。</p>
<h3 id="3-4-自定义类加载器"><a href="#3-4-自定义类加载器" class="headerlink" title="3.4 自定义类加载器"></a>3.4 自定义类加载器</h3><p>下面看一个简单的带 Javassist 的类加载器：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> javassist.*;</div><div class="line"></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SampleLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</div><div class="line">    <span class="comment">/* Call MyApp.main(). */</span></div><div class="line">    public static void main(<span class="type">String</span>[] args) <span class="keyword">throws</span> <span class="type">Throwable</span> &#123;</div><div class="line">        <span class="type">SampleLoader</span> s = <span class="keyword">new</span> <span class="type">SampleLoader</span>();</div><div class="line">        <span class="type">Class</span> c = s.loadClass(<span class="string">"MyApp"</span>);</div><div class="line">        c.getDeclaredMethod(<span class="string">"main"</span>, <span class="keyword">new</span> <span class="type">Class</span>[] &#123; <span class="type">String</span>[].<span class="keyword">class</span> &#125;)</div><div class="line">         .invoke(<span class="literal">null</span>, <span class="keyword">new</span> <span class="type">Object</span>[] &#123; args &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="type">ClassPool</span> pool;</div><div class="line"></div><div class="line">    public <span class="type">SampleLoader</span>() <span class="keyword">throws</span> <span class="type">NotFoundException</span> &#123;</div><div class="line">        pool = <span class="keyword">new</span> <span class="type">ClassPool</span>();</div><div class="line">        pool.insertClassPath(<span class="string">"./class"</span>); <span class="comment">// MyApp.class must be there.</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* </span></div><div class="line">     * Finds a specified class.</div><div class="line">     * The bytecode for that class can be modified.</div><div class="line">     */</div><div class="line">    <span class="keyword">protected</span> <span class="type">Class</span> findClass(<span class="type">String</span> name) <span class="keyword">throws</span> <span class="type">ClassNotFoundException</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="type">CtClass</span> cc = pool.get(name);</div><div class="line">            <span class="comment">// *modify the CtClass object here*</span></div><div class="line">            byte[] b = cc.toBytecode();</div><div class="line">            <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="type">NotFoundException</span> e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">ClassNotFoundException</span>();</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="type">IOException</span> e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">ClassNotFoundException</span>();</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="type">CannotCompileException</span> e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">ClassNotFoundException</span>();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>MyApp 类是一个应用程序。 要执行此程序，首先将类文件放在 ./class 目录下，它不能包含在类搜索路径中。 否则，MyApp.class 将由默认系统类加载器加载，它是 SampleLoader 的父加载器。目录名 ./class 由构造函数中的 insertClassPath() 指定。然后运行：</p>
<p><code>% java SampleLoader</code></p>
<p>类加载器会加载类 MyApp (./class/MyApp.class)，并使用命令行参数调用 MyApp.main()。</p>
<p>这是使用 Javassist 的最简单的方法。 但是，如果你编写一个更复杂的类加载器，你可能需要更详细地了解 Java 的类加载机制。 例如，上面的程序将 MyApp 类放在与 SampleLoader 类不同的命名空间中，因为这两个类由不同的类装载器加载。 因此，MyApp 类不能直接访问类 SampleLoader。</p>
<h3 id="3-5-修改系统的类"><a href="#3-5-修改系统的类" class="headerlink" title="3.5 修改系统的类"></a>3.5 修改系统的类</h3><p>像 java.lang.String 这样的系统类只能被系统类加载器加载。因此，上面的 SampleLoader 或 javassist.Loader 在加载时不能修改系统类。系统类必须被静态地修改。下面的程序向 java.lang.String 添加一个新字段 hiddenValue：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ClassPool pool = ClassPool.getDefault()<span class="comment">;</span></div><div class="line">CtClass cc = pool.get(<span class="string">"java.lang.String"</span>)<span class="comment">;</span></div><div class="line">CtField f = new CtField(CtClass.intType, <span class="string">"hiddenValue"</span>, cc)<span class="comment">;</span></div><div class="line">f.setModifiers(Modifier.PUBLIC)<span class="comment">;</span></div><div class="line">cc.<span class="keyword">addField(f);</span></div><div class="line">cc.writeFile(<span class="string">"."</span>)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>这段程序生成一个新文件 ./java/lang/String.class</p>
<p>可以使用 MyApp 这样测试修改过的 String 类：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">%</span> java -Xbootclasspath/p:. MyApp ar<span class="name">g1</span> ar<span class="name">g2.</span>..</div></pre></td></tr></table></figure>
<p>MyApp 的定义如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> MyApp &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) throws Exception &#123;</div><div class="line">        System.out.<span class="built_in">println</span>(<span class="keyword">String</span>.<span class="keyword">class</span>.getField(<span class="string">"hiddenValue"</span>).getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果修改过的 String 类被加载，MyApp 会打印出 hiddenValue。</p>
<p><strong>注意</strong>：如果应用使用此技术来覆盖 rt.jar 中的系统类，那么部署这个应用会违反 Java 2 运行时二进制代码许可协议。</p>
<h3 id="3-6-在运行时重新加载类"><a href="#3-6-在运行时重新加载类" class="headerlink" title="3.6 在运行时重新加载类"></a>3.6 在运行时重新加载类</h3><p>如果 JVM 在启用 JPDA（Java平台调试器体系结构）的情况下启动，那么类可以被动态地重新加载。在 JVM 加载类之后，旧版本的类可以被卸载，新版本可以再次重新加载。也就是说，该类的定义可以在运行时动态被修改。然而，新的类定义必须与旧的类定义有些兼容。JVM 不允许两个版本之间的模式更改。它们必须具有相同的方法和字段。</p>
<p>Javassist 提供了一个方便的类，用于在运行时重新加载类。更多相关信息，请参阅javassist.tools.HotSwapper 的 API 文档。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://erhu.party/2016/11/17/javassist-turorial-1/" data-id="civn7dj170006jsqaigmssykv" class="article-share-link">分享到</a><div class="tags"><a href="/tags/javassist/">javassist</a></div><div class="post-nav"><a href="/2016/11/10/training-of-training/" class="next">培训的培训</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/besier/" style="font-size: 15px;">besier</a> <a href="/tags/camera/" style="font-size: 15px;">camera</a> <a href="/tags/javassist/" style="font-size: 15px;">javassist</a> <a href="/tags/photography/" style="font-size: 15px;">photography</a> <a href="/tags/技术分享/" style="font-size: 15px;">技术分享</a> <a href="/tags/培训/" style="font-size: 15px;">培训</a> <a href="/tags/scinece/" style="font-size: 15px;">scinece</a> <a href="/tags/emacs/" style="font-size: 15px;">emacs</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/11/17/javassist-turorial-1/">Javassist 使用指南（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/10/training-of-training/">培训的培训</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/01/fantastic-ppt/">技术分享圆满成功</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/18/photograph001/">摄影作品001</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/16/besier/">贝塞尔曲线</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/29/get-system-service/">追踪 getSystemService(...)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/29/window-manager/">从源码角度解析悬浮窗</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/28/camera-3/">我的第三台相机</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/26/huan-qiu-ke-xue/">环球科学</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/22/my-first-emacs-function/">我的第一个Emacs函数</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">四十岁退休.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>